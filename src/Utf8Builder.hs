{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE NoImplicitPrelude #-}

{-
Test out the Utf8Builder that is part of RIO Prelude.
It gets used by the RIO logging system, such as logInfo, but other than that, not sure why it would be used.
The problem is that it wraps everything in double quotes, including writing to file.
Instead use Text for things like building up error messages, and writing gmsh script files, etc.
-}
module Utf8Builder(test1, test2, test3, showLogWarning, showLogWarningWithMonoid, writeUtf8BuilderToFile, writeByteStringToFile) where

import RIO
--import qualified Prelude as P
import Test.HUnit 
import qualified RIO.Text as T
import qualified RIO.File as RIO.File
import qualified GHC.IO.Handle as H
import qualified RIO.ByteString as B

filePathToTestFile = "src/Data/Utf8BuilderModuleTests.txt"

runTests = do
  runTestTT test1
  runTestTT test2
  runTestTT test3
  runTestTT test4
  

-- | Create a Utf8Builder from Text, and change it back to Text because Utf8Builder is not an instance of Eq, and so will not work with assertEqual.
--  Utf8Builder, via displayShow, add double quotes to the Text, which can only be removed by extracting the text from the UtfBuilder and
--  manually removing them.
test1 = TestCase $ assertEqual
  "test1"
  ("\"text?\"")
  (utf8BuilderToText  $ displayShow "text?")
--Utf8Builder -> Text   show a => a -> Utf8Builder

-- | Same as test1, but use lazy Text.
--  RIO does not recommend the use of lazy Text except when using lazy IO.
test2 = TestCase $ assertEqual
  "test2"
  ("\"text?\"")
  (utf8BuilderToLazyText $ displayShow "text?")

-- | Create 3 Utf8Builders from Text and add them together as a Monoid.
--  Notice that each Text is surrounded by double quotes.
test3 = TestCase $ assertEqual
  "test"
  ("\"aaaaa\"\"bbbbb\"\"ccccc\"")
  (let
     a = displayShow $ "aaaaa"
     b = displayShow "bbbbb"
     c = displayShow "ccccc"
   in
   utf8BuilderToText $ a <> b <> c 
  )

-- | LogWaring outputs Text with quotes.
showLogWarning :: IO ()
showLogWarning =
   let
     a = displayShow  ("aaaaa"::Text)
     b = displayShow $ show "bbbbb"
     c = displayShow "ccccc"
   in
     --putStrLn $ utf8BuilderToText $ a <> b <> c 
     --P.putStr _ --"dfds"
     runSimpleApp $ do
       logInfo a
       logInfo b
       logInfo c

-- | LogWarning showing UftBuilders appended as monoid.
showLogWarningWithMonoid :: IO ()
showLogWarningWithMonoid =
  let
     a = displayShow  ("aaaaa"::Text)
     b = displayShow $ show "bbbbb"
     c = displayShow "ccccc"
   in
     runSimpleApp $ do
       logInfo $ a <> b <> c
       



-- | mappend multiple Text together, then turn into Utf8Builder.
--  In this way, opening/closing quotes only around the entire Text, compared to mappending the UtfBuilders.
--  Need to strip the opening/closing " of which get generated by Text. Weird.
test4 = TestCase $ assertEqual
  "test4"
  ("\"aabbcc\"")
  (let
     
    stripQuotes text = T.dropAround (== '"') text
   in
   --stripQuotes $ utf8BuilderToText $ displayShow $ "aa" <> "bb" <> "cc"
     utf8BuilderToText $ displayShow $ "aa" <> "bb" <> "cc"
  )


-- | Shows that writeFileUtf8Builder will write text that is wrapped in double quotes, which were added by displayShow when it created a Utf8Builder.
writeUtf8BuilderToFile :: IO ()
writeUtf8BuilderToFile =
  writeFileUtf8Builder filePathToTestFile $ displayShow  "ccccc"


-- | Show that writing Text using  RIO.File.writeBinaryFile does not add the double quotes, the way displayShow did in previous test function.
writeByteStringToFile :: IO ()
writeByteStringToFile = do
  --RIO.File.writeBinaryFile filePathToTestFile $ encodeUtf8 "ccccc"
  --encodeUtf8 is used to convert the Text to Utf8.

  --but a simpler way to do this is with writeFileUtf8 which does the encoding automatically.
  writeFileUtf8 filePathToTestFile "ccccc"
  


