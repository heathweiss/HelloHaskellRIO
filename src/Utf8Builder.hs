{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE NoImplicitPrelude #-}

{-
Test out the Utf8Builder that is part of RIO Prelude.
It gets used by the RIO logging system, such as logInfo, but other than that, not sure why it would be used.
The problem is that it wraps everything in double quotes, including writing to file.
Instead use Text for things like building up error messages, and writing gmsh script files, etc.
-}
module Utf8Builder() where

import RIO
import qualified Prelude as P
import Test.HUnit 
import qualified RIO.Text as T
import qualified RIO.File as RIO.File
import qualified System.IO as SIO
import qualified RIO.ByteString as B

--All Utf8Builder filewriting will write to this same file, which may cause unexpected results.
filePathToTestFile = "src/Data/Utf8BuilderModuleTests.txt"

runDisplayTests = do
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------- displaying Utf8Builder ---------------------------------------------------------------------------------------  
-- | Create a Utf8Builder from Text, and change it back to Text because Utf8Builder is not an instance of Eq, and so will not work with assertEqual.
--  Utf8Builder, via displayShow, add double quotes to the Text, which can only be removed by extracting the text from the UtfBuilder and
--  manually removing them.
 let 
  test1 = TestCase $ assertEqual
   "test1"
   ("\"text?\"")
   (utf8BuilderToText  $ displayShow "text?")
 runTestTT test1
 --do same, but use textDisplay, which Utf8Builder gets from being an instance of Display
 --Gives the exact same result.
 let
  test1a = TestCase $ assertEqual
   "test1"
   ("\"text?\"")
   (textDisplay  $  displayShow "text?")
 runTestTT test1a

-- | Same as test1, but use lazy Text.
--  RIO does not recommend the use of lazy Text except when using lazy IO.
 let
  test2 = TestCase $ assertEqual
   "test2"
   ("\"text?\"")
   (utf8BuilderToLazyText $ displayShow "text?")
 runTestTT test2

 -- | Create 3 Utf8Builders from Text and add them together as a Monoid.
 --  Notice that each Text is surrounded by double quotes.
 let
  test3 = TestCase $ assertEqual
   "test"
   ("\"aaaaa\"\"bbbbb\"\"ccccc\"")
   (let
      a = displayShow $ "aaaaa"
      b = displayShow "bbbbb"
      c = displayShow "ccccc"
    in
    utf8BuilderToText $ a <> b <> c 
   )
 runTestTT test3


-- | LogWaring outputs Text with quotes.
showLogWarning :: IO ()
showLogWarning =
   let
     a = displayShow  ("aaaaa"::Text)
     b = displayShow $ show "bbbbb"
     c = displayShow "ccccc"
   in
     --putStrLn $ utf8BuilderToText $ a <> b <> c 
     --P.putStr _ --"dfds"
     runSimpleApp $ do
       logInfo a
       logInfo b
       logInfo c

-- | LogWarning showing UftBuilders appended as monoid.
showLogWarningWithMonoid :: IO ()
showLogWarningWithMonoid =
  let
     a = displayShow  ("aaaaa"::Text)
     b = displayShow $ show "bbbbb"
     c = displayShow "ccccc"
   in
     runSimpleApp $ do
       logInfo $ a <> b <> c
       



-- | mappend multiple Text together, then turn into Utf8Builder.
--  In this way, opening/closing quotes only around the entire Text, compared to mappending the UtfBuilders.
--  Need to strip the opening/closing " of which get generated by Text. Weird.
test4 = TestCase $ assertEqual
  "test4"
  ("\"aabbcc\"")
  (let
     
    stripQuotes text = T.dropAround (== '"') text
   in
   --stripQuotes $ utf8BuilderToText $ displayShow $ "aa" <> "bb" <> "cc"
     utf8BuilderToText $ displayShow $ "aa" <> "bb" <> "cc"
  )


-------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------- writing to file -------------------------------------------------------------------

-- | Shows that writeFileUtf8Builder will write text that is wrapped in double quotes, which were added by displayShow when it created a Utf8Builder.
-- It does overwrite whatever was in the file.
writeUtf8BuilderToFile :: IO ()
writeUtf8BuilderToFile =
  writeFileUtf8Builder filePathToTestFile $ displayShow  "ccccc"



-- | Show that writing Text using  RIO.File.writeBinaryFile does not add the double quotes, the way displayShow did in previous test function.
-- It does overwrite whatever was in the file.
writeByteStringToFile :: IO ()
writeByteStringToFile = do
  --RIO.File.writeBinaryFile filePathToTestFile $ encodeUtf8 "ccccc"
  --encodeUtf8 is used to convert the Text to Utf8.
  --but a simpler way to do this is with writeFileUtf8 which does the encoding automatically.
  writeFileUtf8 filePathToTestFile "ccccc"

-- | Create a ByteString from pieces, then write it to file using RIO.ByteString.hPut. 
-- Writes to file without the formatting problems of Utf8Builder.
writeByteStringToFileWithHandle :: IO ()
writeByteStringToFileWithHandle = do
  h <-  SIO.openFile  filePathToTestFile SIO.WriteMode
  let abc = encodeUtf8 "abc"
  --B.hPut h $  "abc" <> "def"
  B.hPut h $  abc <> "def" <>  "ghi"
  B.hPut h "jkl"
  SIO.hClose h




-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------- building up a Builder with UTF8Builder ----------------------------------------------
{-
Utf8Builder is in the RIO prelude: https://hackage.haskell.org/package/rio-0.1.14.1/docs/RIO.html#t:Utf8Builder


Builder is in RIO.Prelude.Types: https://hackage.haskell.org/package/rio-0.1.14.1/docs/RIO-Prelude-Types.html#t:Builder
-}
